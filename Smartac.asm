#make_bin#

; BIN is plain binary format similar to .com format, but not limited to 1 segment;
; All values between # are directives, these values are saved into a separate .binf file.
; Before loading .bin file emulator reads .binf file with the same file name.

; All directives are optional, if you don't need them, delete them.

; set loading address, .bin file will be loaded to this address:
#LOAD_SEGMENT=0500h#
#LOAD_OFFSET=0000h#

; set entry point:
#CS=0500h#	; same as loading segment
#IP=0000h#	; same as loading offset

; set segment registers
#DS=0500h#	; same as loading segment
#ES=0500h#	; same as loading segment

; set stack
#SS=0500h#	; same as loading segment
#SP=FFFEh#	; set to top of loading segment

; set general registers (optional)
#AX=0000h#
#BX=0000h#
#CX=0000h#
#DX=0000h#
#SI=0000h#
#DI=0000h#
#BP=0000h#

; add your code here
JMP  _CODE
;TIMER-1 ADDRESS
CT0 EQU 30H
CT1 EQU 32H
CT2 EQU 34H
CRG EQU 36H
; 8255-1 ADDRESS
PA1 EQU 10H
PB1 EQU 12H
PC1 EQU 14H
CA1 EQU 16H
; 8255-2 ADDRESS
PA2 EQU 20H
PB2 EQU 22H
PC2 EQU 24H
CA2 EQU 26H
; 8255-3 ADDRESS
PA3 EQU 40H
PB3 EQU 42H
PC3 EQU 44H
CA3 EQU 46H
; USER DATA
VENTSTATE DB 0
TEMPDISPLAY DB 25
TIMEDISPLAY DB 03H ; STORES FIRST TWO DIGITS OF TIME

_CODE:
MOV AL, 80H
OUT CA1, AL
;INITIALISE 8255-2
MOV AL, 90H
OUT CA2, AL
;INTIALISE 8255-3
MOV AL, 83H
OUT CA3, AL
MOV AL,6
CALL RESET_PUSH
;INIT LCD
CALL LCD_INIT
MOV TIMEDISPLAY,3
MOV TEMPDISPLAY,25
MOV AL,01100000B
OUT PC3,AL
CALL TIME_WRITE
	LABEL1:CALL DELAY
		IN AL,PC3
		AND AL,00001010B
		CMP AL,0
		JE LABEL1
		
		MOV BL,AL
		AND BL,00000010B
		CMP BL,0
		JE CHECK2
		MOV BL,TIMEDISPLAY
		ADD BL,3
		MOV TIMEDISPLAY,BL
		CMP BL,36
		JLE CHECK3
		MOV BL,3
		MOV TIMEDISPLAY,BL
		
		CHECK3:CALL TIME_WRITE
		CHECK2:
		MOV BL,AL
		AND BL,08H
		CMP BL,0
		CALL RESET_PUSH
		JNE LABEL2
		
	JMP LABEL1
	LABEL2:CALL RESET_PUSH
	CALL TEMP_WRITE
	CALL TIMER_INIT
	CALL COUNTER_INIT
	
	LABEL3:
		IN AL,PB3;CHECK IF OPERATION TIME HAS ELAPSED
		AND AL,0FH
		MOV AH,0
		MOV DL,3
		MUL DL
		CMP AL,TIMEDISPLAY
		JGE EXIT
		
		IN AL,PC3;CHECK IF TEMPERATURE PUSH BUTTON WAS PRESSED
		AND AL,00000100B
		CMP AL,0
		JE NORMAL;CONTINUE NORMAL FUNCTIONING
		;ELSE INCREASE TEMPERATURE AND DISPLAY IT
		ADD TEMPDISPLAY,1
		CMP TEMPDISPLAY,35
		JLE DISPLAY
		MOV TEMPDISPLAY, 16
		DISPLAY:
		CALL TEMP_WRITE
		CALL RESET_PUSH
		CALL DELAY_SHORT
		
		NORMAL:;GETS VENTSTATE IN INPUT
			MOV AL,0
			RE:
				CALL GET_TEMP;OUTPUTS TEMPERATURE IN CL
				MOV CH,0
				
				PUSH AX
					MOV AX,CX
					MOV CX,100
					MUL CX
					MOV DX,0
					MOV BX,256
					DIV BX
					OUT PC1,AL
					CALL DELAY
					CALL DELAY
					CMP AL,TEMPDISPLAY
					JG OPEN
				POP AX
				MOV DL,0FEH
				MOV CL,AL
				ROL DL,CL
				AND VENTSTATE,DL
				JMP VENTDONE
				OPEN:POP AX
				MOV DL,01H
				MOV CL,AL
				ROL DL,CL
				OR VENTSTATE,DL
				VENTDONE:
				CALL DELAY
				INC AL
				CMP AL,4
			JNZ RE
		MOV AL,VENTSTATE
		OUT PB2,AL
		CALL DELAY;CALL DELAY OF 20 MILISECOND
	JMP LABEL3
	
	EXIT:;;;;;CLOSE ALL VENTS ,YOU HAVENT DONE THIS YET
	MOV AL,0
	OUT PB2,AL
_STOP: JMP _STOP

GET_TEMP PROC NEAR
	;ASSUMING AL HAS THE SENSOR TO BE SELECTED
	PUSH AX
	PUSH BX
	MOV BL,AL;STORE COPY OF AL
	out PC2, al
		
	OR al,00100000b;ALE
	out PC2,al
	
	CALL DELAY_SHORT
	
	OR al,00110000b;SOC
	out PC2,al
	
	CALL DELAY_SHORT
	
	AND al,11011111b;ALE 0
	out PC2,al
	
	CALL DELAY_SHORT
	
	AND al,11001111b;SOC 0
	out PC2,al
	
	RE1:;WAIT FOR EOC
	CALL DELAY_SHORT
	IN AL, PC3
	AND AL, 01H
	CMP AL,0
	JZ RE1
	
	CALL DELAY_SHORT
	
	MOV AL,BL;SET OE HIGH
	OR AL,00001000B
	OUT PC2, AL
	
	CALL DELAY_SHORT
	
	IN AL, PA2;TAKE TEMPERATURE AS INPUT
	MOV CL,AL
	
	CALL DELAY_SHORT
	
	MOV AL,BL;SET OE LOW
	AND AL,00000111B
	OUT PC2,AL
	
	CALL DELAY_SHORT
	
	POP BX
	POP AX
	RET
GET_TEMP ENDP

LCD_INIT PROC NEAR
	PUSH AX
	MOV AL, 38H ;INITIALIZE LCD FOR 2 LINES & 5*7 MATRIX
	CALL COMNDWRT ;WRITE THE COMMAND TO LCD
	CALL DELAY ;WAIT BEFORE ISSUING THE NEXT COMMAND
	MOV AL, 0EH ;SEND COMMAND FOR LCD ON, CURSOR ON
	CALL COMNDWRT
	CALL DELAY
	CALL CLS
	MOV AL, 06 ;COMMAND FOR SHIFTING CURSOR RIGHT
	CALL COMNDWRT
	CALL DELAY
	POP AX
	RET
LCD_INIT ENDP

TIMER_INIT PROC NEAR ;STARTS TIMER SO IT GENERATES PULSES AT EVERY 30 MINUTES
	PUSH AX; INITIALIZE 1ST COUNTER
	MOV AL,34H
	OUT CRG,AL
	MOV AL,0E8H
	OUT CT0,AL
	MOV AL,03H
	OUT CT0,AL
	; INIT 2ND COUNTER
	MOV AL,74H
	OUT CRG,AL
	MOV AL,0E8H
	OUT CT1,AL
	MOV AL,03H
	OUT CT1,AL
	;INIT 3RD COUNTER
	MOV AL,0B4H
	OUT CRG,AL
	MOV AL,94H
	OUT CT2,AL
	MOV AL,11H
	OUT CT2,AL
	POP AX
	RET
TIMER_INIT ENDP

COUNTER_INIT PROC NEAR 
	PUSH AX
	MOV AL,01000000B
	OUT PC3,AL
	MOV AL,0
	OUT PA3,AL
	MOV AL,01100000B
	OUT PC3,AL
	POP AX
	RET
COUNTER_INIT ENDP

DATWRIT PROC NEAR
	PUSH DX ;save DX
	PUSH AX
	OUT PA1, AL ;issue the char to LCD
	MOV AL, 00000101B ;RS=1, R/W=0, E=1 for H-to-L pulse
	
	OUT PB1, AL ;make enable high
	nop
	nop
	MOV AL, 00000001B ;RS=1,R/W=0 and E=0 for H-to-L pulse
	OUT PB1, AL
	POP AX
	POP DX
	RET
DATWRIT ENDP ;writing on the lcd ends



COMNDWRT PROC NEAR;THIS PROCEDURE WRITES COMMANDS TO LCD
	PUSH AX
	OUT PA1, AL ;SEND THE CODE TO PORT A
	MOV AL, 00000100B ;RS=0,R/W=0,E=1 FOR H-TO-L PULSE
	OUT PB1, AL
	NOP
	NOP
	MOV AL, 00000000B ;RS=0,R/W=0,E=0 FOR H-TO-L PULSE
	OUT PB1, AL
	POP AX
	RET
COMNDWRT ENDP


;DELAY IN THE CIRCUIT HERE THE DELAY OF 20 MILLISECOND IS
;PRODUCED
DELAY PROC NEAR
	PUSH CX
	MOV CX, 1325 ;1325*15.085 USEC = 20 MSEC
	W1:
	NOP
	NOP
	NOP
	NOP
	NOP
	LOOP W1
	POP CX
	RET
DELAY ENDP
DELAY_SHORT PROC NEAR
	PUSH CX
	MOV CX,10 ;10*15.085 USEC = 150 USEC
	Work:
	NOP
	NOP
	NOP
	NOP
	NOP
	LOOP Work
	POP CX
	RET
DELAY_SHORT ENDP

RESET_PUSH PROC NEAR
	PUSH AX
	MOV AL,00100000B
	OUT PC3,AL
	NOP
	NOP
	MOV AL,01100000B
	OUT PC3,AL
	POP AX
	RET
RESET_PUSH ENDP

TEMP_WRITE PROC NEAR
	PUSH AX
	PUSH BX
	CALL CLS
	CALL LCD_INIT
	CALL DELAY ;WAIT BEFORE ISSUING THE NEXT CHARACTER
	MOV BL, 10
	MOV AL, TEMPDISPLAY
	MOV AH,00
	DIV BL
	ADD AL, '0' ;DISPLAY TENS OF TEMP
	CALL DATWRIT ;ISSUE IT TO LCD
	CALL DELAY ;WAIT BEFORE ISSUING THE NEXT CHARACTER
	MOV AL, AH
	ADD AL, '0' ;DISPLAY ONES OF TEMP
	CALL DATWRIT ;ISSUE IT TO LCD
	CALL DELAY ;WAIT BEFORE ISSUING THE NEXT CHARACTER
	POP BX
	POP AX
	RET
TEMP_WRITE ENDP

TIME_WRITE PROC NEAR
	PUSH AX
	PUSH BX
	MOV AL,0
	OUT PB1,AL
	CALL DELAY
	CALL CLS
	CALL LCD_INIT
	MOV BL, 10
	MOV AL, TIMEDISPLAY
	MOV AH,00
	DIV BL
	ADD AL, '0' ;DISPLAY HUNDREDS OF TIME
	CALL DATWRIT ;ISSUE IT TO LCD
	CALL DELAY ;WAIT BEFORE ISSUING THE NEXT CHARACTER
	MOV AL, AH
	ADD AL, '0' ;DISPLAY TENS OF TIME
	CALL DATWRIT ;ISSUE IT TO LCD
	CALL DELAY ;WAIT BEFORE ISSUING THE NEXT CHARACTER
	MOV AL, '0' ;DISPLAY ONES OF TEMP
	CALL DATWRIT ;ISSUE IT TO LCD
	CALL DELAY ;WAIT BEFORE ISSUING THE NEXT CHARACTER
	POP BX
	POP AX
	RET
TIME_WRITE ENDP

CLS PROC NEAR
	PUSH AX
	MOV AL, 01 ;CLEAR LCD
	CALL COMNDWRT
	CALL DELAY
	POP AX
	RET
CLS ENDP

HLT           ; halt!